<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Django数据库防注入]]></title>
    <url>%2F2019%2F04%2F28%2FDjango%2FDjango%E6%95%B0%E6%8D%AE%E5%BA%93%E9%98%B2%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[Django SQL防注入SQL注入是所有网站建设都应该注意防范的东西，使用Django当然也不例外。下面介绍几个Django中防范SQL注入的方案。 方案一 总是使用Django自带的数据库API。它会根据你所使用的数据库服务器（例如PostSQL或者MySQL）的转换规则，自动转义特殊的SQL参数。这被运用到了整个Django的数据库API中，只有一些例外： 传给 extra() 方法的 where 参数。 (参考 附录 C。) 这个参数故意设计成可以接受原始的SQL。 使用底层数据库API的查询。 方案二 看下面的Python代码： from django.db import connectiondef user_contacts(request): user = request.GET[*'username'*] sql = *"SELECT \* FROM user_contacts WHERE* *username* *= %s"* cursor = connection.cursor() cursor.execute(sql, [user]) # 通过传参的方式执行原生SQL # ... do something with the results 请注意在cursor.execute() 的SQL语句中使用“%s”，而不要在SQL内直接添加参数。 如果你使用这项技术，数据库基础库将会自动添加引号，同时在必要的情况下转意你的参数。]]></content>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django小知识]]></title>
    <url>%2F2019%2F04%2F28%2FDjango%2FDjango%E5%B0%8F%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[查看model列名Billing_Cost.objects.get(id=1)._meta.fields 忽略模版渲染语法使用标签verbatim endverbatim Model只查询特定列的结果Billing_Cost.objects.values(‘resource_type’,’change_time’).get(id=1) Model查询排除特定列的结果Billing_Cost.objects.defer(‘resource_type’,’change_time’).values().get(id=1)]]></content>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器]]></title>
    <url>%2F2019%2F04%2F28%2FJavaScript%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[CSS 选择器元素选择器/* group 1 */h1 &#123;color:silver; background:white;&#125;h2 &#123;color:silver; background:gray;&#125;h3 &#123;color:white; background:gray;&#125;h4 &#123;color:silver; background:white;&#125;b &#123;color:gray; background:white;&#125;/* group 2 */h1, h2, h4 &#123;color:silver;&#125;h2, h3 &#123;background:gray;&#125;h1, h4, b &#123;background:white;&#125;h3 &#123;color:white;&#125;b &#123;color:gray;&#125;/* group 3 */h1, h4 &#123;color:silver; background:white;&#125;h2 &#123;color:silver;&#125;h3 &#123;color:white;&#125;h2, h3 &#123;background:gray;&#125;b &#123;color:gray; background:white;&#125; 通配符选择器* &#123;color:red;&#125; ID选择器#intro &#123;font-weight:bold;&#125; 只能在文档中使用一次 不能结合使用 类选择器.important &#123;color:red;&#125;p.important &#123;color:red;&#125; /*结合元素选择器*/.important.warning &#123;background:silver;&#125; /*选择同时包含多个类*/ 属性选择器[title] &#123;color:red;&#125;a[href] &#123;color:red;&#125;a[href][title] &#123;color:red;&#125;a[href='http://baidu.com'] &#123;color:red;&#125;p[class~="important"] &#123;color: red;&#125; /*根据部分属性值选择*/ 后代选择器（派生选择）h1 em &#123;color:red;&#125; 后代选择器有一个易被忽视的方面，即两个元素之间的层次间隔可以是无限的。 子元素选择器h1 &gt; strong &#123;color:red;&#125; /*父元素为h1的strong元素*/table.company td &gt; p 两个元素之间的层次间隔是一层。 没有父类选择器，因为html渲染是从外层到里层的，根据子类影响父类，违背了渲染顺序。 兄弟选择器h1 + p &#123;margin-top:50px;&#125; /*与h1相邻的p元素*/ 两个元素在同一层 伪类选择器锚伪类a:link &#123;color: #FF0000&#125; /* 未访问的链接 */a:visited &#123;color: #00FF00&#125; /* 已访问的链接 */a:hover &#123;color: #FF00FF&#125; /* 鼠标移动到链接上 */a:active &#123;color: #0000FF&#125; /* 选定的链接 */ 提示：在 CSS 定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。 提示：在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。 first-child 伪类p:first-child &#123;font-weight: bold;&#125; /* 选择作为第一个子元素的 p 元素 */p:first-of-type &#123;font-weight: bold;&#125; /* 指定父元素的首个 p 元素 */p &#123;font-weight: bold;&#125; /* 选择所有p元素 */p &gt; i:first-child &#123; font-weight:bold;&#125; /* 匹配p元素的第一个li子元素*/p:first-child i &#123; color:blue;&#125; /* 匹配第一个p元素所有li元素*/ :first-child 伪类来选择作为第一个子元素的 xxx 元素。(这个元素是其父元素的第一个子元素) :first-of-type 伪元素选择的是指定父元素的首个 xxx 元素（这个元素可以不是其父元素的第一个子元素） 选择器参考：(来自菜鸟教程) 选择器 例子 例子描述 CSS .class .intro 选择 class=”intro” 的所有元素。 1 #id #firstname 选择 id=”firstname” 的所有元素。 1 * * 选择所有元素。 2 element p 选择所有 &amp;lt;p&amp;gt; 元素。 1 element,element div,p 选择所有 &amp;lt;div&amp;gt; 元素和所有 &amp;lt;p&amp;gt; 元素。 1 element element div p 选择 &amp;lt;div&amp;gt; 元素内部的所有 &amp;lt;p&amp;gt; 元素。 1 element&gt;element div&gt;p 选择父元素为 &amp;lt;div&amp;gt; 元素的所有 &amp;lt;p&amp;gt; 元素。 2 element+element div+p 选择紧接在 &amp;lt;div&amp;gt; 元素之后的所有 &amp;lt;p&amp;gt; 元素。 2 [attribute] [target] 选择带有 target 属性所有元素。 2 [attribute=value] [target=_blank] 选择 target=”_blank” 的所有元素。 2 [attribute~=value] [title~=flower] 选择 title 属性包含单词 “flower” 的所有元素。 2 :link a:link 选择所有未被访问的链接。 1 :visited a:visited 选择所有已被访问的链接。 1 :active a:active 选择活动链接。 1 :hover a:hover 选择鼠标指针位于其上的链接。 1 :focus input:focus 选择获得焦点的 input 元素。 2 :first-letter p:first-letter 选择每个 &amp;lt;p&amp;gt; 元素的首字母。 1 :first-line p:first-line 选择每个 &amp;lt;p&amp;gt; 元素的首行。 1 :first-child p:first-child 选择属于父元素的第一个子元素的每个 &amp;lt;p&amp;gt; 元素。 2 :before p:before 在每个 html &lt;p&amp;gt; 元素的内容之前插入内容。 2 :after p:after 在每个 &amp;lt;p&amp;gt; 元素的内容之后插入内容。 2 :lang(language) p:lang(it) 选择带有以 “it” 开头的 lang 属性值的每个 &amp;lt;p&amp;gt; 元素。 2 element1~element2 p~ul 选择前面有 &amp;lt;p&amp;gt; 元素的每个&lt;ul&amp;gt; 元素。 3 [attribute^=value] a[src^=”https”] 选择其 src 属性值以 “https” 开头的每个 &amp;lt;a&amp;gt; 元素。 3 [attribute$=value] a[src$=”.pdf”] 选择其 src 属性以 “.pdf” 结尾的所有 &amp;lt;a&amp;gt; 元素。 3 [attribute**=value*] a[src*=”abc”] 选择其 src 属性中包含 “abc” 子串的每个 &amp;lt;a&amp;gt; 元素。 3 :first-of-type p:first-of-type 选择属于其父元素的首个 &amp;lt;p&amp;gt; 元素的每个 &amp;lt;p&amp;gt; 元素。 3 :last-of-type p:last-of-type 选择属于其父元素的最后 &amp;lt;p&amp;gt; 元素的每个 &amp;lt;p&amp;gt; 元素。 3 :only-of-type p:only-of-type 选择属于其父元素唯一的 &amp;lt;p&amp;gt; 元素的每个 &amp;lt;p&amp;gt; 元素。 3 :only-child p:only-child 选择属于其父元素的唯一子元素的每个 &amp;lt;p&amp;gt; 元素。 3 :nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &amp;lt;p&amp;gt; 元素。 3 :nth-last-child(n) p:nth-last-child(2) 同上，从最后一个子元素开始计数。 3 :nth-of-type(n) p:nth-of-type(2) 选择属于其父元素第二个 &amp;lt;p&amp;gt; 元素的每个 &amp;lt;p&amp;gt; 元素。 3 :nth-last-of-type(n) p:nth-last-of-type(2) 同上，但是从最后一个子元素开始计数。 3 :last-child p:last-child 选择属于其父元素最后一个子元素每个 &amp;lt;p&amp;gt; 元素。 3 :root :root 选择文档的根元素。 3 :empty p:empty 选择没有子元素的每个 &amp;lt;p&amp;gt; 元素（包括文本节点）。 3 :target #news:target 选择当前活动的 #news 元素。 3 :enabled input:enabled 选择每个启用的 &amp;lt;input&amp;gt; 元素。 3 :disabled input:disabled 选择每个禁用的 &amp;lt;input&amp;gt; 元素 3 :checked input:checked 选择每个被选中的 &amp;lt;input&amp;gt; 元素。 3 :not(selector) :not(p) 选择非 &amp;lt;p&amp;gt; 元素的每个元素。 3 ::selection ::selection 选择被用户选取的元素部分。 3 一个有趣的练习网站： http://flukeout.github.io]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery基础知识]]></title>
    <url>%2F2019%2F04%2F28%2FJavaScript%2FJQuery%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JQuery基础知识# 来源：廖雪峰js教程 https://www.liaoxuefeng.com jQuery能帮我们干这些事情： 消除浏览器差异：你不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写AJAX等代码； 简洁的操作DOM的方法：写$(‘#test’)肯定比document.getElementById(‘test’)来得简洁； 轻松实现动画、修改CSS等各种操作。 $符号$是著名的jQuery符号。实际上，jQuery把所有功能全部封装在一个全局变量jQuery中，而$也是一个合法的变量名，它是变量jQuery的别名： window.jQuery; // jQuery(selector, context)window.$; // jQuery(selector, context)$ === jQuery; // truetypeof($); // 'function' $本质上就是一个函数，但是函数也是对象，于是$除了可以直接调用外，也可以有很多其他属性。 选择器// 按ID查找var div = $('#abc');// 按Tag查找var ps = $('p'); // 返回所有&lt;p&gt;节点ps.length; // 数一数页面有多少个&lt;p&gt;节点// 按Class查找var a = $('.red'); // 所有节点包含`class="red"`都将返回// 按属性查找var email = $('[name=email]'); // 找出&lt;??? name="email"&gt;var passwordInput = $('[type=password]'); // 找出&lt;??? type="password"&gt;var a = $('[items="A B"]'); // 找出&lt;??? items="A B"&gt;//按属性查找还可以使用前缀查找或者后缀查找：var icons = $('[name^=icon]'); // 找出所有name属性值以icon开头的DOM// 例如: name="icon-1", name="icon-2"var names = $('[name$=with]'); // 找出所有name属性值以with结尾的DOM// 例如: name="startswith", name="endswith"var icons = $('[class^="icon-"]'); // 找出所有class包含至少一个以`icon-`开头的DOM// 组合查找var emailInput = $('input[name=email]');var tr = $('tr.red'); // 找出&lt;tr class="red ..."&gt;...&lt;/tr&gt;// 多项选择器$('p,div'); // 把&lt;p&gt;和&lt;div&gt;都选出来$('p.red,p.green'); // 把&lt;p class="red"&gt;和&lt;p class="green"&gt;都选出来 jQuery的选择器不会返回undefined或者null, 如果无符合的对象，返回的jQuery对象是[]。 jQuery对象和DOM对象之间可以互相转化： var div = $('#abc'); // jQuery对象var divDom = div.get(0); // 假设存在div，获取第1个DOM元素var another = $(divDom); // 重新把DOM包装为jQuery对象 更高级的选择器&lt;!-- HTML结构 --&gt;&lt;div class="testing"&gt; &lt;ul class="lang"&gt; &lt;li class="lang-javascript"&gt;JavaScript&lt;/li&gt; &lt;li class="lang-python"&gt;Python&lt;/li&gt; &lt;li class="lang-lua"&gt;Lua&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;// 层级选择器$('ul.lang li'); // 选出JavaScript、Python和Lua 3个节点$('ul.lang li.lang-javascript');$('div.testing li.lang-javascript');// 子选择器 $('parent&gt;child')类似层级选择器，但是限定了层级关系必须是父子关系，就是&lt;child&gt;节点必须是&lt;parent&gt;节点的直属子节点。$('ul.lang&gt;li.lang-javascript'); // 可以选出[&lt;li class="lang-javascript"&gt;JavaScript&lt;/li&gt;]$('div.testing&gt;li.lang-javascript'); // [], 无法选出，因为&lt;div&gt;和&lt;li&gt;不构成父子关系// 过滤器$('ul.lang li:first-child'); // 仅选出JavaScript$('ul.lang li:last-child'); // 仅选出Lua$('ul.lang li:nth-child(2)'); // 选出第N个元素，N从1开始$('ul.lang li:nth-child(even)'); // 选出序号为偶数的元素$('ul.lang li:nth-child(odd)'); // 选出序号为奇数的元素// 查找和过滤// 用find()从元素中查找var ul = $('ul.lang'); // 获得&lt;ul&gt;var dy = ul.find('.dy'); // 获得JavaScript, Python, Schemevar swf = ul.find('#swift'); // 获得Swiftvar hsk = ul.find('[name=haskell]'); // 获得Haskell// 用parent()向上查找var swf = $('#swift'); // 获得Swiftvar parent = swf.parent(); // 获得Swift的上层节点&lt;ul&gt;var a = swf.parent('.red'); // 获得Swift的上层节点&lt;ul&gt;，同时传入过滤条件。如果ul不符合条件，返回空jQuery对象// next()和prev()向后向前查找var swift = $('#swift');swift.next(); // Schemeswift.next('[name=haskell]'); // 空的jQuery对象，因为Swift的下一个元素Scheme不符合条件[name=haskell]swift.prev(); // Pythonswift.prev('.dy'); // Python，因为Python同时符合过滤器条件.dy// filter()从中过滤var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskellvar a = langs.filter('.dy'); // 拿到JavaScript, Python, Scheme// 切片var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskellvar js = langs.first(); // JavaScript，相当于$('ul.lang li:first-child')var haskell = langs.last(); // Haskell, 相当于$('ul.lang li:last-child')var sub = langs.slice(2, 4); // Swift, Scheme, 参数和数组的slice()方法一致 操作DOM// 修改文本$('#test-ul li[name=book]').text(); // 'Java &amp; JavaScript'$('#test-ul li[name=book]').text('修改内容'); // 'Java &amp; JavaScript'$('#test-ul li[name=book]').html(); // 'Java &amp;amp; JavaScript'// 修改cssvar div = $('#test-div');div.css('color'); // '#000033', 获取CSS属性div.css('color', '#336699'); // 设置CSS属性div.css('color', ''); // 清除CSS属性// 修改classvar div = $('#test-div');div.hasClass('highlight'); // false， class是否包含highlightdiv.addClass('highlight'); // 添加highlight这个classdiv.removeClass('highlight'); // 删除highlight这个class// 显示和隐藏DOMvar a = $('a[target=_blank]');a.hide(); // 隐藏a.show(); // 显示// 获取DOM信息// 浏览器可视窗口大小:$(window).width(); // 800$(window).height(); // 600// HTML文档大小:$(document).width(); // 800$(document).height(); // 3500// 某个div的大小:var div = $('#test-div');div.width(); // 600div.height(); // 300div.width(400); // 设置CSS属性 width: 400px，是否生效要看CSS是否有效div.height('200px'); // 设置CSS属性 height: 200px，是否生效要看CSS是否有效// attr()和removeAttr()方法用于操作DOM节点的属性// &lt;div id="test-div" name="Test" start="1"&gt;...&lt;/div&gt;var div = $('#test-div');div.attr('data'); // undefined, 属性不存在div.attr('name'); // 'Test'div.attr('name', 'Hello'); // div的name属性变为'Hello'div.removeAttr('name'); // 删除name属性div.attr('name'); // undefined// prop()方法和attr()类似，但是HTML5规定有一种属性在DOM节点中可以没有值，只有出现与不出现两种，例如：// &lt;input id="test-radio" type="radio" name="test" checked value="1"&gt;// 对于checked，使用prop会更好。// 判断是否被选中var radio = $('#test-radio');radio.is(':checked'); // truevar select = $('#test-select');select.is(':selected')// 操作表单// 对于表单元素，jQuery对象统一提供val()方法获取和设置对应的value属性：input.val(); // 'test' 取值input.val('abc@example.com'); // 赋值 修改DOM结构// 添加DOMul.append('&lt;li&gt;&lt;span&gt;Haskell&lt;/span&gt;&lt;/li&gt;'); // 在ul里面添加li// 同级节点可以用after()或者before()方法js.after('&lt;li&gt;&lt;span&gt;Lua&lt;/span&gt;&lt;/li&gt;'); // 在js元素后面添加Lua// 删除节点$('#test-div&gt;ul&gt;li').remove(); // 所有&lt;li&gt;全被删除 事件// 获取超链接的jQuery对象:var a = $('#test-link');a.on('click', function () &#123; alert('Hello!');&#125;); on方法用来绑定一个事件，我们需要传入事件名称和对应的处理函数。 鼠标事件click: 鼠标单击时触发；dblclick：鼠标双击时触发；mouseenter：鼠标进入时触发；mouseleave：鼠标移出时触发；mousemove：鼠标在DOM内部移动时触发；hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。 键盘事件键盘事件仅作用在当前焦点的DOM上，通常是和。keydown：键盘按下时触发；keyup：键盘松开时触发；keypress：按一次键后触发。 其他事件focus：当DOM获得焦点时触发；blur：当DOM失去焦点时触发；change：当、或的内容改变时触发；submit：当提交时触发；ready：当页面被载入并且DOM树完成初始化后触发。ready仅作用于document对象。 ready方法可以避免js在DOM未加载完毕之前执行相关绑定或方法。所以我们自己的初始化代码必须放到document对象的ready事件中，保证DOM已完成初始化。 // 直接使用ready方法$(document).ready(function () &#123; // on('submit', function)也可以简化: $('#testForm).submit(function () &#123; alert('submit!'); &#125;);&#125;);// 甚至可以省略ready$(function () &#123; // init...&#125;); 可以反复绑定事件处理函数，它们会依次执行 事件参数// 所有事件都会传入Event对象作为参数，可以从Event对象上获取到更多的信息$(function () &#123; $('#testMouseMoveDiv').mousemove(function (e) &#123; // e就是时间参数 $('#testMouseMoveSpan').text('pageX = ' + e.pageX + ', pageY = ' + e.pageY); &#125;);&#125;); 取消绑定// 一个已被绑定的事件可以解除绑定，通过off('click', function)实现，function对象必须与绑定的对象为同一个对象。function hello() &#123; alert('hello!');&#125;a.click(hello); // 绑定事件// 10秒钟后解除绑定:setTimeout(function () &#123; a.off('click', hello);&#125;, 10000);// 需要特别注意的是，下面这种写法是无效的,两个是不同的函数对象。a.click(function () &#123; alert('hello!');&#125;);a.off('click', function () &#123; alert('hello!');&#125;);a.off('click') // 一次性移除已绑定的click事件的所有处理函数a.off() // 移除所有类型的事件处理函数。 取消绑定可以实现比如拦截表单提交等操作。 form.off().submit(function (e) &#123; // 移除表单所有事件，并绑定新的submit事件 e.preventDefault(); // 通知 Web 浏览器不要执行与事件关联的默认动作 alert(form.serialize()); // 打印表格信息&#125;); 事件触发条件一个需要注意的问题是，事件的触发总是由用户操作引发的。如果用JavaScript代码去改动文本框的值，将不会触发change事件。 有些时候，我们希望用代码触发change事件，可以直接调用无参数的change()方法来触发该事件： var input = $('#test-input');input.val('change it!'); // 通过js修改不会触发change事件input.change(); // 触发change事件 浏览器安全限制在浏览器中，有些JavaScript代码只有在用户触发下才能执行，例如，window.open()函数。 var button1 = $('#testPopupButton1');var button2 = $('#testPopupButton2');function popupTestWindow() &#123; window.open('/');&#125;button1.click(function () &#123; popupTestWindow();&#125;);button2.click(function () &#123; // 不立刻执行popupTestWindow()，100毫秒后执行: setTimeout(popupTestWindow, 100);&#125;); 当用户点击button1时，click事件被触发，由于popupTestWindow()在click事件处理函数内执行，这是浏览器允许的，而button2的click事件并未立刻执行popupTestWindow()，延迟执行的popupTestWindow()将被浏览器拦截。 动画用JavaScript实现动画，原理非常简单：我们只需要以固定的时间间隔（例如，0.1秒），每次把DOM元素的CSS样式修改一点（例如，高宽各增加10%），看起来就像动画了。 // 左上角div.hide(3000); // 在3秒钟内逐渐消失div.show('slow'); // 在0.6秒钟内逐渐显示div.toggle('slow') // 根据当前状态决定是show()还是hide()。// 垂直方向div.slideUp(3000); // 在3秒钟内逐渐向上消失div.slideDown('slow')div.slideToggle('slow')// 淡入淡出div.fadeOut('slow')div.fadeIn('slow')div.fadeToggle('slow') 自定义动画animate()可以实现任意动画效果，我们需要传入的参数就是DOM元素最终的CSS状态和时间，jQuery在时间段内不断调整CSS直到达到我们设定的值。 var div = $('#test-animate');div.animate(&#123; opacity: 0.25, width: '256px', height: '256px'&#125;, 3000); // 在3秒钟内CSS过渡到设定值// animate()还可以再传入一个函数，当动画结束时，该函数将被调用var div = $('#test-animate');div.animate(&#123; opacity: 0.25, width: '256px', height: '256px'&#125;, 3000, function () &#123; console.log('动画已结束'); // 恢复至初始状态: $(this).css('opacity', '1.0').css('width', '128px').css('height', '128px');&#125;); 串行动画jQuery的动画效果还可以串行执行，通过delay()方法还可以实现暂停，这样，我们可以实现更复杂的动画效果，而代码却相当简单。 var div = $('#test-animates');// 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小div.slideDown(2000) .delay(1000) .animate(&#123; width: '256px', height: '256px' &#125;, 2000) .delay(1000) // 延迟1秒 .animate(&#123; width: '128px', height: '128px' &#125;, 2000);&#125; 停止动画$("#stop").click(function()&#123; $("#panel").stop();&#125;); 语法: $(selector).stop(stopAll,goToEnd); 可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。因此，默认地，stop() 会清除在被选元素上指定的当前动画。]]></content>
      <tags>
        <tag>JQuery基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dashboard安装]]></title>
    <url>%2F2019%2F04%2F28%2FLinux%2FDashboard%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Dashboard安装kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml# 修改node为NodePort模式kubectl patch svc -n kube-system kubernetes-dashboard -p '&#123;"spec":&#123;"type":"NodePort"&#125;&#125;'# 查看服务(得知dashboard运行在30972端口)kubectl get svc -n kube-system# --- 输出 ---NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEkube-dns ClusterIP 10.96.0.10 &lt;none&gt; 53/UDP,53/TCP,9153/TCP 7h40mkubernetes-dashboard NodePort 10.111.77.210 &lt;none&gt; 443:30972/TCP 3h42m# --- 输出 ---# 查看dashboard运行在哪个node(得知dashboard运行在192.168.20.4)kubectl get pods -A -o wide# --- 输出 ---NAMESPACE NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESkube-system coredns-fb8b8dccf-rn8kd 1/1 Running 0 7h43m 10.244.0.2 master &lt;none&gt; &lt;none&gt;kube-system coredns-fb8b8dccf-slwr4 1/1 Running 0 7h43m 10.244.0.3 master &lt;none&gt; &lt;none&gt;kube-system etcd-master 1/1 Running 0 7h42m 192.168.20.5 master &lt;none&gt; &lt;none&gt;kube-system kube-apiserver-master 1/1 Running 0 7h42m 192.168.20.5 master &lt;none&gt; &lt;none&gt;kube-system kube-controller-manager-master 1/1 Running 0 7h42m 192.168.20.5 master &lt;none&gt; &lt;none&gt;kube-system kube-flannel-ds-amd64-l8c7c 1/1 Running 0 7h3m 192.168.20.5 master &lt;none&gt; &lt;none&gt;kube-system kube-flannel-ds-amd64-lcmxw 1/1 Running 1 6h50m 192.168.20.4 node1 &lt;none&gt; &lt;none&gt;kube-system kube-flannel-ds-amd64-pqnln 1/1 Running 1 6h5m 192.168.20.3 node2 &lt;none&gt; &lt;none&gt;kube-system kube-proxy-4kcqb 1/1 Running 0 7h43m 192.168.20.5 master &lt;none&gt; &lt;none&gt;kube-system kube-proxy-jcqjd 1/1 Running 0 6h5m 192.168.20.3 node2 &lt;none&gt; &lt;none&gt;kube-system kube-proxy-vm9sj 1/1 Running 0 6h50m 192.168.20.4 node1 &lt;none&gt; &lt;none&gt;kube-system kube-scheduler-master 1/1 Running 0 7h42m 192.168.20.5 master &lt;none&gt; &lt;none&gt;kube-system kubernetes-dashboard-5f7b999d65-2ltmv 1/1 Running 0 3h45m 10.244.1.2 node1 &lt;none&gt; &lt;none&gt;# --- 输出 ---# 如果无法变成Running状态，可以使用以下命令排错journalctl -f -u kubelet # 只看当前的kubelet进程日志,要到dashboard所在的node执行### 若提示拉取镜像失败，无法翻墙的可以使用以下方法预先拉取镜像### 请在kubernetes-dashboard的节点上操作：docker pull mirrorgooglecontainers/kubernetes-dashboard-amd64:v1.10.1docker tag mirrorgooglecontainers/kubernetes-dashboard-amd64:v1.10.1 k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1docker rmi mirrorgooglecontainers/kubernetes-dashboard-amd64:v1.10.1 根据上面的信息可以得知dashboard的ip和端口，使用火狐浏览器访问https://192.168.20.4:30972（必须使用**https**，所以会提示不安全，火狐浏览器可以添加例外，谷歌浏览器不行。） # 创建dashboard管理用户kubectl create serviceaccount dashboard-admin -n kube-system# 绑定用户为集群管理用户kubectl create clusterrolebinding dashboard-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin# 生成tockenkubectl describe secret -n kube-system dashboard-admin-token# --- 输出如下 ---Name: dashboard-admin-token-pb78xNamespace: kube-systemLabels: &lt;none&gt;Annotations: kubernetes.io/service-account.name: dashboard-admin kubernetes.io/service-account.uid: 166aeb8d-604e-11e9-80d6-080027d8332bType: kubernetes.io/service-account-tokenData====ca.crt: 1025 bytesnamespace: 11 bytestoken: eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkYXNoYm9hcmQtYWRtaW4tdG9rZW4tcGI3OHgiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGFzaGJvYXJkLWFkbWluIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiMTY2YWViOGQtNjA0ZS0xMWU5LTgwZDYtMDgwMDI3ZDgzMzJiIiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmUtc3lzdGVtOmRhc2hib2FyZC1hZG1pbiJ9.WYV8iBXsGikehSknd4QKbbwVSHn5K0NF1DYi4JHL-wyHtLusuEFeP89s19iC_yXu_5nOsC0h4E3Q19C7XfkGtm37WwMdsJqFjzL2VjVs5NaOUGAeXAVcuHdx0Hrzo3MCu6e1t27KWxGEFwEQv0FNhHwJ9pBmEkJz5fLyGzNOmJqYh2bifL4hrtbnCduWXR4wdnNwtGvcnafGsEvl-QkYpH1h5GRc9A2qZoSKJC90LW-kIRB_0elhwqCg-UM2a0b9cOlbgbZAEseIb3gSHpxLomkziHEjYadBA5bhmSdlArRGQs3DhMcp9pFWarXZEKR5wtxrRdam5mJykXnxA-qwNg# ------ 使用生成的tocken就可以登录dashboard了。]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7部署k8s集群-kubeadm]]></title>
    <url>%2F2019%2F04%2F28%2FLinux%2Fcentos7%E9%83%A8%E7%BD%B2k8s%E9%9B%86%E7%BE%A4-kubeadm%2F</url>
    <content type="text"><![CDATA[centos7 部署 k8s 集群安装docker-ce官方文档 Master、Node节点都需要安装、配置Docker # 卸载原来的dockersudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine# 安装依赖sudo yum update -y &amp;&amp; sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2# 添加官方yum库sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo# 安装dockersudo yum install docker-ce docker-ce-cli containerd.io# 查看docker版本docker --version# 开机启动systemctl enable --now docker 或者使用脚本一键安装 curl -fsSL "https://get.docker.com/" | shsystemctl enable --now docker 修改docker cgroup驱动，与k8s一致，使用systemd # 修改docker cgroup驱动：native.cgroupdriver=systemdcat &gt; /etc/docker/daemon.json &lt;&lt;EOF&#123; "exec-opts": ["native.cgroupdriver=systemd"], "log-driver": "json-file", "log-opts": &#123; "max-size": "100m" &#125;, "storage-driver": "overlay2", "storage-opts": [ "overlay2.override_kernel_check=true" ]&#125;EOFsystemctl restart docker # 重启使配置生效 安装 kubelet kubeadm kubectl官方文档 master、node节点都需要安装kubelet kubeadm kubectl。 安装kubernetes的时候，需要安装kubelet, kubeadm等包，但k8s官网给的yum源是packages.cloud.google.com，国内访问不了，此时我们可以使用阿里云的yum仓库镜像。 cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF# 关闭SElinuxsetenforce 0sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config# 安装kubelet kubeadm kubectlyum install -y kubelet kubeadm kubectl --disableexcludes=kubernetessystemctl enable --now kubelet # 开机启动kubelet# centos7用户还需要设置路由：yum install -y bridge-utils.x86_64modprobe br_netfilter # 加载br_netfilter模块，使用lsmod查看开启的模块cat &lt;&lt;EOF &gt; /etc/sysctl.d/k8s.confnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOFsysctl --system # 重新加载所有配置文件systemctl disable --now firewalld # 关闭防火墙# k8s要求关闭swapswapoff -a &amp;&amp; sysctl -w vm.swappiness=0 # 关闭swapsed -ri '/^[^#]*swap/s@^@#@' /etc/fstab # 取消开机挂载swap 使用虚拟机的可以做完以上步骤后，进行克隆。实验环境为1 Master，2 Node 创建集群准备工作# Master端：kubeadm config images pull # 拉取集群所需镜像，这个需要翻墙# --- 不能翻墙可以尝试以下办法 ---kubeadm config images list # 列出所需镜像# 根据所需镜像名字先拉取国内资源docker pull mirrorgooglecontainers/kube-apiserver:v1.14.1docker pull mirrorgooglecontainers/kube-controller-manager:v1.14.1docker pull mirrorgooglecontainers/kube-scheduler:v1.14.1docker pull mirrorgooglecontainers/kube-proxy:v1.14.1docker pull mirrorgooglecontainers/pause:3.1docker pull mirrorgooglecontainers/etcd:3.3.10docker pull coredns/coredns:1.3.1 # 这个在mirrorgooglecontainers中没有# 修改镜像tagdocker tag mirrorgooglecontainers/kube-apiserver:v1.14.1 k8s.gcr.io/kube-apiserver:v1.14.1docker tag mirrorgooglecontainers/kube-controller-manager:v1.14.1 k8s.gcr.io/kube-controller-manager:v1.14.1docker tag mirrorgooglecontainers/kube-scheduler:v1.14.1 k8s.gcr.io/kube-scheduler:v1.14.1docker tag mirrorgooglecontainers/kube-proxy:v1.14.1 k8s.gcr.io/kube-proxy:v1.14.1docker tag mirrorgooglecontainers/pause:3.1 k8s.gcr.io/pause:3.1docker tag mirrorgooglecontainers/etcd:3.3.10 k8s.gcr.io/etcd:3.3.10docker tag coredns/coredns:1.3.1 k8s.gcr.io/coredns:1.3.1# 把所需的镜像下载好，init的时候就不会再拉镜像，由于无法连接google镜像库导致出错# 删除原来的镜像docker rmi mirrorgooglecontainers/kube-apiserver:v1.14.1docker rmi mirrorgooglecontainers/kube-controller-manager:v1.14.1docker rmi mirrorgooglecontainers/kube-scheduler:v1.14.1docker rmi mirrorgooglecontainers/kube-proxy:v1.14.1docker rmi mirrorgooglecontainers/pause:3.1docker rmi mirrorgooglecontainers/etcd:3.3.10docker rmi coredns/coredns:1.3.1# Node端：# 根据所需镜像名字先拉取国内资源docker pull mirrorgooglecontainers/kube-proxy:v1.14.1docker pull mirrorgooglecontainers/pause:3.1# 修改镜像tagdocker tag mirrorgooglecontainers/kube-proxy:v1.14.1 k8s.gcr.io/kube-proxy:v1.14.1docker tag mirrorgooglecontainers/pause:3.1 k8s.gcr.io/pause:3.1# 删除原来的镜像docker rmi mirrorgooglecontainers/kube-proxy:v1.14.1docker rmi mirrorgooglecontainers/pause:3.1# --- 不能翻墙可以尝试使用 --- 使用kubeadm创建集群# 第一次初始化过程中/etc/kubernetes/admin.conf该文件存在，是空文件（我自己手多创建的），会报错：panic: runtime error: invalid memory address or nil pointer dereferencels /etc/kubernetes/admin.conf &amp;&amp; mv /etc/kubernetes/admin.conf&#123;,.bak&#125; # 移走备份# 初始化Master（Master需要至少2核）kubeadm init --apiserver-advertise-address 192.168.20.5 --pod-network-cidr 10.244.0.0/16 # --kubernetes-version 1.14.1# --apiserver-advertise-address 指定与其它节点通信的接口# --pod-network-cidr 指定pod网络子网，10.244.0.0与fannel网络对应 运行初始化，程序会检验环境一致性，可以根据实际错误提示进一步修复问题。 程序会访问https://dl.k8s.io/release/stable-1.txt获取最新的k8s版本，访问这个连接需要FQ，如果无法访问，则会使用kubeadm client的版本作为安装的版本号，使用kubeadm version查看client版本。也可以使用–kubernetes-version明确指定版本。 # 初始化结果：[init] Using Kubernetes version: v1.14.1[preflight] Running pre-flight checks[preflight] Pulling images required for setting up a Kubernetes cluster[preflight] This might take a minute or two, depending on the speed of your internet connection[preflight] You can also perform this action in beforehand using &apos;kubeadm config images pull&apos;[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;[kubelet-start] Activating the kubelet service[certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot;[certs] Using existing etcd/ca certificate authority[certs] Using existing etcd/server certificate and key on disk[certs] Using existing etcd/peer certificate and key on disk[certs] Using existing etcd/healthcheck-client certificate and key on disk[certs] Using existing apiserver-etcd-client certificate and key on disk[certs] Using existing ca certificate authority[certs] Using existing apiserver certificate and key on disk[certs] Using existing apiserver-kubelet-client certificate and key on disk[certs] Using existing front-proxy-ca certificate authority[certs] Using existing front-proxy-client certificate and key on disk[certs] Using the existing &quot;sa&quot; key[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file[control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot;[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;[etcd] Creating static Pod manifest for local etcd in &quot;/etc/kubernetes/manifests&quot;[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;/etc/kubernetes/manifests&quot;. This can take up to 4m0s[apiclient] All control plane components are healthy after 21.503375 seconds[upload-config] storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace[kubelet] Creating a ConfigMap &quot;kubelet-config-1.14&quot; in namespace kube-system with the configuration for the kubelets in the cluster[upload-certs] Skipping phase. Please see --experimental-upload-certs[mark-control-plane] Marking the node master as control-plane by adding the label &quot;node-role.kubernetes.io/master=&apos;&apos;&quot;[mark-control-plane] Marking the node master as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule][bootstrap-token] Using token: w2i0mh.5fxxz8vk5k8db0wq[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster[bootstrap-token] creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace[addons] Applied essential addon: CoreDNS[addons] Applied essential addon: kube-proxyYour Kubernetes control-plane has initialized successfully!To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/Then you can join any number of worker nodes by running the following on each as root:kubeadm join 192.168.20.5:6443 --token w2i0mh.5fxxz8vk5k8db0wq \ --discovery-token-ca-cert-hash sha256:65e82e987f50908f3640df7e05c7a91f390a02726c9142808faa739d4dc24252 普通用户设置权限mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config 应用flannel网络# master：cat ~/.kube/config# node：# 复制master的config内容vim ~/.kube/config # 把master的内容拷贝到node中，这样就可以在node节点中找到apiserver，使用kubectl# master：wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.ymlvim kube-flannel.yml # kube-flannel中添加args指定通信接口ip（可以使用正则），添加iface-regex参数，如下面的图所示（不需要使用引号引住！！！）。kubectl apply -f kube-flannel.yml # 应用flannel网络ps -ef | grep flannel # 确保master和node都有flannel进程，如果node节点没有flannel进程，可以尝试在node也按上述步骤apply一次。 这里需要指定master与节点之间通信的接口，如果有多网卡，默认是使用默认路由的网卡，所以必须要在此明确指定，否则会导致pod相互不通的问题。 node加入机器# 根据master初始化的提示# node1:kubeadm join 192.168.20.5:6443 --token w2i0mh.5fxxz8vk5k8db0wq \ --discovery-token-ca-cert-hash sha256:65e82e987f50908f3640df7e05c7a91f390a02726c9142808faa739d4dc24252# node2:kubeadm join 192.168.20.5:6443 --token w2i0mh.5fxxz8vk5k8db0wq \ --discovery-token-ca-cert-hash sha256:65e82e987f50908f3640df7e05c7a91f390a02726c9142808faa739d4dc24252 输出日志： [preflight] Running pre-flight checks[preflight] Reading configuration from the cluster...[preflight] FYI: You can look at this config file with &apos;kubectl -n kube-system get cm kubeadm-config -oyaml&apos;[kubelet-start] Downloading configuration for the kubelet from the &quot;kubelet-config-1.14&quot; ConfigMap in the kube-system namespace[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;[kubelet-start] Activating the kubelet service[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...This node has joined the cluster:* Certificate signing request was sent to apiserver and a response was received.* The Kubelet was informed of the new secure connection details.Run &apos;kubectl get nodes&apos; on the control-plane to see this node join the cluster. # master：kubectl get pods --all-namespaces# ---输出信息（全部ready才是正常的）---NAMESPACE NAME READY STATUS RESTARTS AGEkube-system coredns-fb8b8dccf-rn8kd 1/1 Running 0 170mkube-system coredns-fb8b8dccf-slwr4 1/1 Running 0 170mkube-system etcd-master 1/1 Running 0 169mkube-system kube-apiserver-master 1/1 Running 0 169mkube-system kube-controller-manager-master 1/1 Running 0 169mkube-system kube-flannel-ds-amd64-l8c7c 1/1 Running 0 130mkube-system kube-flannel-ds-amd64-lcmxw 1/1 Running 1 117mkube-system kube-flannel-ds-amd64-pqnln 1/1 Running 1 72mkube-system kube-proxy-4kcqb 1/1 Running 0 170mkube-system kube-proxy-jcqjd 1/1 Running 0 72mkube-system kube-proxy-vm9sj 1/1 Running 0 117mkube-system kube-scheduler-master 1/1 Running 0 169m# ---输出信息---kubectl get nodes# ---输出信息（全部ready才是正常的）---NAME STATUS ROLES AGE VERSIONmaster Ready master 171m v1.14.1node1 Ready &lt;none&gt; 118m v1.14.1node2 Ready &lt;none&gt; 74m v1.14.1# ---输出信息--- 排错 # 可以在master和node节点上查看日志journalctl -f # 当前输出日志journalctl -f -u kubelet # 只看当前的kubelet进程日志 kubectl命令补全 source &lt;(kubectl completion zsh) # zsh为我使用的shell，请根据实际填]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql备份]]></title>
    <url>%2F2019%2F04%2F28%2FLinux%2FMysql%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[Mysql备份使用mysqldump做逻辑备份 备份基本命令mysqldump -u user -p DATABASES TABLE1 TABLE2… &gt; backup.sql 选项说明 mysqldump 默认是锁表的，如果不需要锁表，请使用 –skip-lock-tables 备份所有数据库使用 -all-databases 排除数据表 –ignore-table=dbname.tablename 备份前刷新binlog日志 –flush-logs 只导出数据结构 –no-data, -d 导出时，包括创建数据库语句 -B 恢复命令mysql -u user -p -e “source backup.sql” DATABASES 选项说明 进入数据库执行命令 -e 通过binlog恢复出现问题后先备份binlog，不要直接还原（会引入新binlog） 恢复命令的语法格式：(binlog里面包含了所有的数据库的日志)mysqlbinlog mysql-bin.0000xx | mysql -u用户名 -p密码 数据库名 常用参数选项解释：–start-position=875 起始pos点–stop-position=954 结束pos点–start-datetime=”2016-9-25 22:01:08” 起始时间点–stop-datetime=”2019-9-25 22:09:46” 结束时间点–database=zyyshop 指定只恢复zyyshop数据库(一台主机上往往有多个数据库，只限本地log日志) 如何查找pos(每个binlog都是独立的pos，对于多个binlog，可以使用时间恢复，但使用pos更精准) 先查看配置，查找binlog文件位置：vim /etc/my.cnf 查看当前binlog位置：show master status; 根据特征SQL语句过滤binlog：mysql -e “show binlog events in ‘mysql-bin.000003’\G;” | grep ‘drop database xxxx’ -A20 -B 30 参考文章 使用XtraBackup做物理备份 安装 依赖：yum -y install perl perl-devel libaio libaio-devel perl-Time-HiRes perl-DBD-MySQL rsync perl perl-Digest-MD5 获取包：wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.4.13/binary/redhat/7/x86_64/percona-xtrabackup-24-2.4.13-1.el7.x86_64.rpm 安装：rpm -ivh percona-xtrabackup-24-2.4.13-1.el7.x86_64.rpm 全量备份命令： innobackupex –user=XXX –password=XXX 全量备份目录 –no-timestamp 参数： 不使用时间戳 –no-timestamp（默认会自动在备份目录下生成时间戳文件夹，格式如：2019-02-22_10-55-47） 增量备份命令： innobackupex –user=XXX –password=XXX –incremental-basedir 增量备份目录 –incremental 全量备份目录 –no-timestamp 备份恢复命令： service mysqld stop # 先停止mysql mv /var/lib/mysql /var/lib/mysql.bak &amp;&amp; mkdir /var/lib/mysql # 备份原来的mysql目录(视my.cnf配置文件而定) cd /usr/bin/ # 可能没有命令环境变量，需要进入目录使用命令 innobackupex –apply-log –redo-only /data/backup/2017-02-23/12/ # 先应用全量备份 innobackupex –apply-log –redo-only /data/backup/2017-02-23/12/ –incremental-dir=/data/backup/2017-02-23/13/ # 添加增量备份，顺序不能错。 innobackupex –apply-log –redo-only /data/backup/2017-02-23/12/ –incremental-dir=/data/backup/2017-02-23/14/ # 添加增量备份，顺序不能错。 innobackupex –apply-log /data/backup/2017-02-23/12/ # 最后使用这个整合所有备份 innobackupex –copy-back /data/backup/2017-02-23/12/ # 复制回mysql数据目录 chown -R mysql.mysql /var/lib/mysql # 修改数据库权限 /etc/init.d/mysqld start # 开启Mysql服务 备注 恢复数据后mysql启动不了，提示Can’t open and lock privilege tables: Table ‘mysql.host’ doesn’t exist，使用如下命令就可以了： mysql_install_db 恢复后的mysql忘记密码，在配置文件中加入skip-grant-tables=1 跳过权限验证。 在恢复的mysql数据目录中，有xtrabackup_binlog_pos_innodb文件记录着binlog文件和开始节点，后续再利用binlog恢复。]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7搭建Harbor企业级docker仓库]]></title>
    <url>%2F2019%2F04%2F28%2FLinux%2Fcentos7%E6%90%AD%E5%BB%BAHarbor%E4%BC%81%E4%B8%9A%E7%BA%A7docker%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[centos7搭建Harbor企业级docker仓库安装dockercurl -fsSL "https://get.docker.com/" | shsystemctl enable --now docker 安装docker-composeyum update -yyum install python-pippip install --upgrade setuptools # 可能由于setuptools版本过低报错pip install docker-compose # 如果报错可以试试 --ignore-installed 安装Harborwget -P /usr/local/src/ https://storage.googleapis.com/harbor-releases/release-1.7.0/harbor-online-installer-v1.7.5.tgz # 在线安装# 最新版本请查看https://github.com/goharbor/harbor/releases/cd /usr/local/src/tar zxf harbor-online-installer-v1.7.5.tgz -C /usr/local/cd /usr/local/harbor/bash install.sh # 使用--with-clair添加镜像漏洞扫描功能 配置文件vim /usr/local/harbor/harbor.cfg # harbor配置文件# 找到以下项目并且修改hostname = test.com # 修改访问域名，如果使用其它端口，请在后面添加端口号，如test.com:8080#邮箱配置（根据实际账号配置）email_server = smtp.qq.comemail_server_port = 465email_username = test@qq.comemail_password = 123456email_from = test@qq.com # 经测试发现必须要和email_username相同才可以发邮件email_ssl = true # 开启ssl保护，使用端口465，关闭使用端口25#禁止用户注册self_registration = off#设置只有管理员可以创建项目project_creation_restriction = adminonly#设置管理员密码harbor_admin_password = 123456 容器集群管理cd /usr/local/harbor/docker-compose ps # 查看harbor集群容器，安装后已经启动# ---------- 控制 ----------# 必须要在/usr/local/harbor/目录下，或者-f指定docker-compose.yml# 启动Harbordocker-compose start# 停止Harbordocker-comose stop# 重启Harbordocker-compose restart# 移除Harbordocker-compose down -v # -v 参数移除vloume# 重新创建并启动docker-compose up -d# ---------- 控制 ---------- 修改nginx端口（如有需要）vim /usr/local/harbor/docker-compose.yml# 把proxy下的80:80改为8080:80则为使用8080访问harbordocker-compose stop proxy # proxy其实就是nginxdocker-compose up -d proxy # 重新开启nginxnetstat -lntp # 查看本地打开端口，如果有docker-proxy为8080则修改成功# 如果有安全组防火墙，记得先放行对应端口 访问网页使用账号admin，默认密码Harbor12345，如果修改了配置文件的密码，则使用上面修改的密码。 默认是所有人可以创建用户登录的，只是上面安装配置中禁止了用户注册。 系统配置中可以设置邮箱配置，认证配置、垃圾清理等，但是不可以设置web打开的端口。 通过漏洞扫描，可以分析出镜像存在的一些漏洞缺陷编码，并且提供修复建议。 上传、下载镜像# 由于使用80端口需要备案，harbor页面已经修改为8080端口（注意修改harbor.cfg的hostname后需要重新执行install.sh）vim /etc/docker/daemon.json# 添加 "insecure-registries":["test.com:8080"] &#125;docker login test.com:8080 # 尝试登录# 编写dockerfilemkdir ~/test_harbor &amp;&amp; cd ~/test_harborcat &lt;&lt; EOF &gt; DockerfileFROM nginx:latestMAINTAINER test "test@qq.com"# 配置环境变量ENV LANG=C.UTF-8 TZ=Asia/ShanghaiEOF# build镜像docker build -t test.com:8080/library/nginx:latest .# push镜像到远程仓库docker push test.com:8080/library/nginx:latest# 从远程仓库拉取镜像docker pull test.com:8080/library/nginx:latest 参考链接 为什么有了Docker registry还需要Harbor？]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云磁盘分区与扩容]]></title>
    <url>%2F2019%2F04%2F28%2FLinux%2F%E9%98%BF%E9%87%8C%E4%BA%91%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E4%B8%8E%E6%89%A9%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[使用parted磁盘分区yum -y install parted# 一行执行：parted /dev/vdb mklabel GPT "YES" mkpart "vdb1" "ext4" "0" "100%" "I" # 建议使用命令parted /dev/vdb分步执行mkfs.ext4 /dev/vdb1 &gt; /dev/null # ext4文件系统tune2fs -c -1 -i -1 /dev/vdb1 &gt; /dev/null # 定义自检周期,-1表示关闭自检mkdir -p /data/mount /dev/vdb1 /data # 挂载到目录blkid | awk /vdb1/'&#123;print $2" /data ext4 defaults 0 0"&#125;' &gt;&gt; /etc/fstab # 添加开机启动挂载 阿里云数据盘扩容yum install -y lsof lsof /data # 检查磁盘被什么程序占用 umount /data/ # 卸载磁盘 parted /dev/vdb “p” “F” “rm 1” “unit s” “mkpart vdb1 ext4 0 100%” “Yes” “I” # CentOS parted /dev/vdb “rm 1” “mkpart vdb1 ext4 0 100%” “Yes” “I” # debian parted /dev/vdb pWarning: Not all of the space available to /dev/vdb appears to be used, you can fix the GPT to use all of the space (an extra 104857600 blocks) or continue with the current setting?Fix/Ignore? F # 通常检测到磁盘大写变化才会有这个提示，如果没有可能需要重启！rm 1unit smkpart vdb1 ext4 0 100% # yesIquit e2fsck -f /dev/vdb1resize2fs /dev/vdb1mount /dev/vdb1 /data/]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面向对象概述]]></title>
    <url>%2F2019%2F04%2F28%2FPython%2Fpython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[面向对象编程概述对象具有以下特征： 万物皆对象 每个对象唯一 对象具有属性和行为 对象具有状态（属性的取值） 对象分为类对象和实例对象两大类 面向对象编程的步骤： 抽象出类对象 抽象出类对象的属性 抽象出类对象的方法 根基类对象创建实例对象 通过实例对象访问属性和方法 Python是动态语言，所以可以对类动态地绑定类方法，在实例对象创建之后，也可以对其动态地绑定实例方法。# 动态绑定方法from types import MethodTypeclass Animal(object): def __init__(self, name): self.name = namedef say_name(self): print(self.name)dog = Animal('dog')cat = Animal('cat')dog.say_name = MethodType(say_name, dog) # 动态绑定实例方法Animal.say_name = say_name # 动态绑定类方法dog.say_name()cat.say_name() 在类对象中定义方法的几种方式。 静态方法使用@staticmethod装饰，只是一个普通的函数，便于管理。 类方法使用@classmethod装饰，需要传入形参cls。 实例方法不需要使用装饰器，需要传入形参self。 # 静态方法、类方法、实例方法class Animal(object): def __init__(self, name): self.name = name @staticmethod def say_hello(): print('hello') @classmethod def say_hi(cls): print('hi') cls.say_hello() def say_name(self): print(self.name) self.say_hello()dog = Animal('dog')dog.say_hello()dog.say_hi()dog.say_name()]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python类属性和方法的访问控制]]></title>
    <url>%2F2019%2F04%2F28%2FPython%2Fpython%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[类属性和方法的访问控制控制类对象的属性和方法在类对象外部是否可以直接访问。在属性或方法前加两个下划线__，那么这个属性就不能从外部访问。 # 私有变量和私有方法class Animal(object): def __init__(self, name): self.name = name __qq = 123123 def __print_qq(self): print(self.__qq) def print_qq(self): print(self.__qq)dog = Animal('dog')dog.print_qq() # 可以输出dog.__print_qq() # AttributeError: 'Animal' object has no attribute '__print_qq'dog.__qq() # AttributeError: 'Animal' object has no attribute '__qq' 之所以不能在类对象的外部直接访问以双划线开头的属性和方法，是因为python解析器对外把属性或方法__xxx改成了另外一个名字：_类名__xxx 而在外部动态绑定一个__开头的属性或方法，与在类中定义的是不同的，不会被python解析器转换，可以直接调用。 # 在外部绑定__属性，不会转换class Animal(object): def __init__(self, name): self.name = name __qq = 123123dog = Animal('dog')dog.__ww = 456456print(dog.__ww) # 可以输出print(dog.__qq) # AttributeError: 'Animal' object has no attribute '__qq' _xx 以单下划线开头的表示的是protected类型的变量。即保护类型只能允许其本身与子类进行访问，也表明最好不要通过外部访问。 若内部变量标示，如： 当使用“from M import”时，不会将以一个下划线开头的对象引入 。]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python封装、继承和多态]]></title>
    <url>%2F2019%2F04%2F28%2FPython%2Fpython%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[封装、继承和多态封装封装的两方面含义： 将数据（属性）和行为（方法）包装到类对象中。在方法内部对属性进行操作，在类对象的外部调用方法。这样，无需关心方法内部的具体实现细节，从而隔离了复杂程度。 在类对象的内部通过访问控制把某些属性和方法隐藏起来，不允许类对象的外部直接访问，而是在类对象的内部对外提供公开的接口方法（例如getter和setter）以访问隐藏的信息。这样，就对隐藏的信息进行了保护。 # 封装class Student(object): def __init__(self): self.__score = 0 # 把内部属性隐藏起来，不允许直接访问 def get_score(self): print(self.__score) def set_score(self, score): # 在方法内部对属性进行操作。 if 100 &gt;= score &gt;= 0: self.__score = score else: raise ValueError('输出数值错误！')xiaoming = Student()xiaoming.set_score(60) # 在类对象的外部调用方法。xiaoming.get_score()xiaoming.set_score(85)xiaoming.get_score() 继承继承是实现代码复用的重要手段。 # 继承class Animal(object): def __init__(self, name): self.name = name def drink(self): print('%s drink water' % self.name) def eat(self): print('%s eat some thing' % self.name)class Dog(Animal): # 继承Animal的属性和方法 def swim(self): print('%s swim' % self.name)class Bird(Animal):# 继承Animal的属性和方法 def fly(self): print('%s fly' % self.name)dog = Dog('dog')bird = Bird('bird')dog.drink()bird.drink()dog.swim()bird.fly() Python中的所有类对象都继承自一个统一的基类：object。 子类只有一个直接父类时，称为==单继承==。子类有多个直接父类时，称为==多继承==。 子类会继承所有父类（包括直接父类和所有间接父类）的所有属性和方法。 重写在子类中定义与父类同名的属性或方法，就可以重写该属性或方法。 子类重写父类方法后，通过子类或其实例对象只能调用子类中重写后的方法，而无法调用父类中被重写分方法。 子类可以通过super().xxx()调用父类中的方法。 ==Python3.x 和 Python2.x 的一个区别是: Python 3 可以使用直接使用 super().xxx 代替 super(Class, self).xxx :== Python3.x 实例： class A: passclass B(A): def add(self, x): super().add(x) Python2.x 实例： class A(object): # Python2.x 记得继承 object passclass B(A): def add(self, x): super(B, self).add(x) 多态简单的说，多态就是“具有多种形态”。 多态可以理解为同样一件事情，不同的人做，会有不同的效果。 一个方法，传递不同的实例对象，执行对应实例的不同方法，产生不同的效果。 # 多态class Animal(object): def __init__(self): self.name = 'Animal' def eat(self): print(self.name + ' eat')class Dog(Animal): def __init__(self): self.name = 'Dog' def bark(self): print(self.name + ' bark')class Bird(Animal): def __init__(self): self.name = 'Bird' def fly(self): print(self.name + ' fly')def animal_eat(animal): # 实现多态的函数 animal.eat()animal = Animal()dog = Dog()bird = Bird()animal_eat(animal)animal_eat(dog)animal_eat(bird) python是动态语言，在调用函数时不会检查参数的类型，从而导致与静态语言（如Java）的多态是有区别的。对于静态语言，实现多态有三个必要的条件： 继承 重写 父类类型的变量引用父类或子类类型的实例对象]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python调用C动态链接库]]></title>
    <url>%2F2019%2F04%2F28%2FPython%2Fpython%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%2F</url>
    <content type="text"><![CDATA[python调用C动态链接库c_dll.c#include&lt;stdio.h&gt;void my_add(int num)&#123; long int result = 0; long int i = 1; for(i; i&lt;=num; i++)&#123; result += i; &#125; printf("C从1到%d累加的计算结果为%ld",num,result);&#125; 编译C文件，生成so文件： ==gcc c_dll.c -shared -o c_dll.so -fPIC== add.py#! coding:utf-8#! /usr/bin/env python'''python调用C动态链接库处理计算密集操作。'''import timefrom ctypes import *def main(): num = int(input("请输入整数值:")) result = 0 start_time = time.time() result = cdll.LoadLibrary("./c_dll.so") # 这里调用的是C源码编译后生成的动态链接库 print(dir(result.my_add)) result.my_add(num) end_time = time.time() print print("总共用时%s"%(end_time-start_time)) p_start_time = time.time() p_result = sum(xrange(num+1)) p_end_time = time.time() print '-'*20 print 'Python从1到%s累加的计算结果为%s'%(num,p_result) print '总共用时%s'%(p_end_time-p_start_time)if __name__ == "__main__": main() 执行结果python c_add.py请输入整数值:1000000000C语言从1到1000000000累加的计算结果为500000000500000000总共用时3.15723800659--------------------P从1到1000000000累加的计算结果为500000000500000000总共用时11.5007269382]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MRO方法解析顺序]]></title>
    <url>%2F2019%2F04%2F28%2FPython%2FMRO%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[MRO 方法解析顺序MRO的全称是Method Resolution Order（方法解析顺序），它指的是一颗类继承树，==当调用最底层类对象所对应实例对象的方法时，Python解析器在类继承树上搜索方法的顺序。== # MRO 方法解析顺序class A(object): def say_hi(self): print('A hi!')class B(A): def say_hi(self): print('B hi!')class C(A): def say_hi(self): print('C hi!')class D(B, C): passd = D()d.say_hi() # B hi!print(D.mro())# (&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)print(D.__mro__)# [&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;] 可以通过类对象.mro()或者特殊方法__mro__来查看类对象的方法解析顺序。 直接使用super()方法来调用父类的方法时，也遵循mro。但是可以给super()方法传递参数，从而调用指定父类的方法。 # super() 与 MROclass A(object): def say_hi(self): print('A hi!')class B(A): def say_hi(self): print('B hi!')class C(A): def say_hi(self): print('C hi!')class D(B, C): def say_hi(self): super(B, self).say_hi() # 调用MRO中B后面那个类的方法d = D()d.say_hi() # C hi!print(D.mro())# (&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python特殊方法]]></title>
    <url>%2F2019%2F04%2F28%2FPython%2Fpython%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Python 特殊方法以双下划线开头和结尾的方法称为特殊方法，__xxxx__。 在定义类对象时，经常会重写一个或多个特殊方法，例如__init__。通常特殊方法都是自动调用的。 __dict__ 获取对象信息# __dict__ 查看对象信息class Animal(object): def __init__(self): self.name = 'Animal' def eat(self): print('eat')animal = Animal()print(Animal.__dict__)'''结果：&#123; '__module__': '__main__', '__init__': &lt;function Animal.__init__ at 0x000001CE58A28D90&gt;, 'eat': &lt;function Animal.eat at 0x000001CE58A28E18&gt;, '__dict__': &lt;attribute '__dict__' of 'Animal' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Animal' objects&gt;, '__doc__': None&#125;'''print(animal.__dict__)# &#123;'name': 'Animal'&#125; __len__ 获取实例对象长度# __len__ 返回对象长度class Animal(object): def __init__(self, name): self.name = name def __len__(self): return len(self.name)dog = Animal('dog')elephant = Animal('elephant')print(len(dog)) # 3print(len(elephant)) # 8 __iter__ 和 __next__ 使实例对象可迭代# __iter__ 和 __next__ 使实例对象可迭代class Student(object): def __init__(self): self.book = ['Math','English','Chinese','Physical'] def __iter__(self): self.count = 0 self.book_list_len = len(self.book) return self # 通常返回的是self def __next__(self): if self.count &lt; self.book_list_len: book_name = self.book[self.count] self.count += 1 return book_name else: raise StopIteration # 停止迭代xiaoming = Student()for i in xiaoming: print(i) __add__ 运算符重载算术运算符可以用于自定义类对象的实例对象，必须在自定义类对象中实现标准算术运算符对应的以下特殊方法： +对应的特殊方法是__add__()和__radd__(); -对应的特殊方法是__sub__()和__rsub__(); *对应的特殊方法是__mul__()和__rmul__(); /对应的特殊方法是__truediv__()和__rtruediv__(); //对应的特殊方法是__floordiv__()和__rfloordiv__() # 实例对象实现加法class Myclass(object): def __init__(self, data): self.data = data def __add__(self, other): # other指的是加号右边的对象 return self.data + other.dataa = Myclass(10)b = Myclass(20)print(a + b) __str__和__repr__ 输出字符# __str__ 和 __repr__class Myclass(object): def __init__(self, data): self.data = data def __str__(self): return self.data def __repr__(self): return self.dataa = Myclass('123')print(a) # 123print(str(a)) # 123print(repr(a)) # 123 str()和repr()都返回对象字符串，其区别在于： str()是给用户看的，显示更加友好。 repr()是给程序开发者看的，为调试服务的。 &gt;&gt;&gt; str('Hello!\nWorld')'Hello!\nWorld'&gt;&gt;&gt; print(str('Hello!\nWorld'))Hello!World&gt;&gt;&gt; repr('Hello!\nWorld')"'Hello!\\nWorld'"&gt;&gt;&gt; print(repr('Hello!\nWorld'))'Hello!\nWorld' __new__ 创建实例方法当使用“类名（实参）”创建实例对象时，python解析器的主要处理过程包括： 调用特殊方法__new__()创建实例对象。 调用特殊方法__init__()对创建的实例对象进行初始化。 __init__中接收的self其实就是__new__中返回的对象。 # __new__ 创建实例调用方法class Animal(object): def __new__(cls, *args, **kwargs): new_object = object.__new__(cls) print('New object id is %s' % id(new_object)) return new_object def __init__(self, name): print('Init object id is %s' % id(self))dog = Animal('123')'''结果：New object id is 2650305182240Init object id is 2650305182240''' __del__ 对象删除方法可以定义__del__来执行当对象被删除时所需的操作。 # __del__ 删除方法import timeclass Animal(object): def __init__(self, name): self.name = name def __del__(self): print('%s对象被删除！' % self.name)dog = Animal('dog')print(dog.name)print('dog对象会在3秒后被删除')time.sleep(3) # 程序结束，必定会删除对象 ==当引用计数器为0时，对象不会立即被销毁（垃圾回收），所以__del__执行的时间也是不确定的。== __getattr__ 获取对象属性或方法# __getattr__class Animal(object): def __init__(self, name): self.name = name def __getattr__(self, item): if item == 'name': return self.name elif item == 'say_name': return self.say_hi else: raise AttributeError('No attribute "%s"' % item) def say_hi(self, value): print('Hi %s!' % value)dog = Animal('dog')print(dog.name) # dogdog.say_hi('cat') # Hi cat!print(dog.age) # AttributeError: No attribute "age" __getitem__、__setitem__、__deltitem__ 索引设置使实例对象实现像列表或者字典索引操作的三个方法。 # __getitem__、__setitem__、__delitem__class Animal(object): def __init__(self): self.data = &#123;&#125; def __getitem__(self, item): return self.data.get(item) def __setitem__(self, key, value): self.data[key] = value def __delitem__(self, key): del self.data[key]dog = Animal()dog['name'] = 'dog'print(dog['name'])del dog['name']print(dog['name']) __call__ 函数调用使实例对象可以像函数一样被调用。 # __call__class Animal(object): def __call__(self, *args, **kwargs): print(args) print(kwargs)dog = Animal()dog(18, 'yellow', name='dog')print(callable(dog))'''结果：(18, 'yellow')&#123;'name': 'dog'&#125;True''' ==可以通过函数callable()来判断对象是否可以被调用。== __doc__ 文档字符串与函数的文档字符串类似，类对象的第一行字符串表示文档字符串。它是对类对象的功能的简要描述。 # __call__class Animal(object): '''这是一个动物类''' passdog = Animal()print(Animal.__doc__)print(dog.__doc__)'''结果：这是一个动物类这是一个动物类''' __slots__ 限制实例对象属性或方法# __slots__class Animal(object): def __init__(self): self.name = 'animal' __slots__ = ('age', 'eat', 'name')dog = Animal()print(dog.name) # animaldog.age = 3def eat(self): print('%s eat!' % self.name)Animal.eat = eatdog.eat() # animal eat!Animal.color = 'withe' # 对于类对象没有影响dog.color = 'withe' # AttributeError: 'Animal' object has no attribute 'color' __slots__对于子类的实例对象是不生效的，如果子类也有__slots__，那么子类的对象可用实例属性或方法则为父类__slots__加子类__slots__。]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pthon小知识点]]></title>
    <url>%2F2019%2F04%2F28%2FPython%2Fpython%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[小知识点issubclass() 用于判断两个类对象之间的关系（是否有继承关系） # issubclass()class A(object): passclass B(A): passclass C(object): passprint(issubclass(B, A)) # Trueprint(issubclass(B, C)) # Falseprint(issubclass(B, (A, C))) # True isinstance() 用于判断实例对象与类对象的关系（是否有创造关系）， # isinstance()class A(object): passclass B(A): passclass C(object): passa = A()b = B()c = C()print(isinstance(a, A)) # Trueprint(isinstance(b, A)) # True 包括继承关系产生的实例对象print(isinstance(c, A)) # Falseprint(isinstance(c, (A, C))) # True# isinstance() 可以用于判断变量的类型a = 123b = '123'c = [1, 2, 3]d = &#123;1:1, 2:2, 3:3&#125;print(isinstance(a, int)) # Trueprint(isinstance(b, str)) # Trueprint(isinstance(c, list)) # Trueprint(isinstance(d, dict)) # True type() 用于获取对象的类型。类对象的类型是type class A(object): passprint(type(A)) # &lt;class 'type'&gt; 可以使用运算符==判断某个对象的类型。对于基本数据类型，可以直接使用其类名；如果不是基本数据类型，需要使用标准库types中的定义的变量。 # 判断非基本数据类型import typesdef say_hi(): passif type(say_hi) == types.FunctionType: # 判断函数 print('This is a function')if type(print) == types.BuiltinFunctionType: # 判断内置函数 print('This is a built-in-function') 查看某个对象的引用sys.getrefcount() # 对象引用计数import sys# 引用计数加一的4中情况a = [1, 2, 3] # 第一个引用b = [a, 4] # 第二个引用c = a # 第三个引用print(sys.getrefcount(a)) # 第四个引用（作为实参）# 当函数执行完后，a的引用计数自动减一 pprint模块中的pprint可以使字典打印更加美观。 import pprintclass Animal(object): passpprint.pprint(Animal.__dict__)'''结果：mappingproxy(&#123;'__dict__': &lt;attribute '__dict__' of 'Animal' objects&gt;, '__doc__': None, '__module__': '__main__', '__weakref__': &lt;attribute '__weakref__' of 'Animal' objects&gt;&#125;)''' 列表使用insert插入元素到某个索引，可以使用del 来直接删除某个索引元素 a = [1, 2, 3]a.insert(1, 9) # 在索引1中插入元素9，后面元素往后挪一位print(a) # [1, 9, 2, 3]del a[2] # 删除索引2的元素，后面元素往前挪一位print(a) # [1, 9, 3]]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pthon反射]]></title>
    <url>%2F2019%2F04%2F28%2FPython%2Fpython%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[Python反射所谓“反射”，指的是以字符串的形式来操作（包括：增删改查）对象的属性和方法 。 用于“反射”的内置函数有以下四个： hasattr getattr setattr delattr # 反射的四个内置方法class Animal(object): def __init__(self): self.name = 'animal' def eat(self): print('%s eat' % self.name)dog = Animal()print(hasattr(dog, 'name')) # Trueprint(getattr(dog, 'name')) # animalsetattr(dog, 'name','dog') # 相当于dog.name = dogprint(getattr(dog, 'name')) # dogdelattr(dog, 'name') # 相当于del dog.nameprint(hasattr(dog, 'name')) # False 只有在不知道对象信息的情况下，才会去获取对象信息。 举个例子：别的程序传给你一个变量var，这个变量是一个字符串，并且这个字符串对应某个模块下的某个函数名，如果你通过变量var直接导入该模块下的该函数，肯定是不行的，因为var是个变量，这时就可以使用反射，例如：var=”xxx” f=getattr(module,var)，这样，就得到了var对应的模块中的函数f，接下来就可以调用f了。]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pthon模块]]></title>
    <url>%2F2019%2F04%2F28%2FPython%2Fpython%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[pthon模块为什么使用模块？ 代码重用 避免属性冲突 为了更好地组织和管理模块，python引入了包，在某个目录下添加模块__init__.py后，该目录就变成了包。目录支持嵌套，所以包也支持嵌套，包中还可以有子包。 相对导入使用相对路径导入模块时，其中，一个.表示当前目录，两个..表示当前目录的父目录。当直接运行某个模块时，该模块就变成了主模块。主模块位于最顶层，与同目录下的其它模块无法形成相对关系。因此，当直接运行某个模块时，该模块不能相对导入。 import语句的执行流程当使用import语句导入模块时，解析器会根据sys模块的modules属性值来查找模块是否已经导入了。 如果模块已经被导入，解析器不做任何操作。 如果模块没有被导入， （1）解析器按照某种路径搜索模块； （2）讲搜索到的模块编译为pyc字节码文件；（可选） （3）执行编译生成的字节码文件从而运行模块。 解析器搜索模块的路径： import sysfrom pprint import pprintpprint(sys.path) 搜索路径主要由三部分组成： 当前目录 标准库目录 第三方库安装目录 修改解析器搜索模块的路径 直接修改sys.path，但是在代码运行后失效。 直接修改PYTHON_PATH 重新加载模块当使用import导入模块之后，模块被修改，如果再次使用import导入模块，是不会生效的。 需要使用importlib中的reload()方法，重新加载模块。 import my_module, timeimport importlibfor i in range(100): importlib.reload(my_module) # 动态重新加载模块 print(my_module.a) time.sleep(1) 模块访问控制当某个模块前加单下划线_时，不能通过import *导入，但是可以通过import _xxx导入。]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
